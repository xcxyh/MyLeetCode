package com.xiong.LeetCode.BitOperation;

/**
 * @author ：xiongcong
 * @date ：Created in 2020/4/22 9:32
 * @description： 面试题64. 求1 + 2 + … + n
 * @modified By：
 * @version: $
 */
public class Leet_Jz64_sumNums {

    public static void main(String[] args) {
        System.out.println(sumNums(5));
    }

    private static int ans = 0;

    private static int sumNums(int n){
        // 利用 && 的短路特性 来完成递归过程
        // 前一个为false了，就不会 执行 && 后面的一个了 相当于递归停止
        boolean bool = n > 0 && sumNums(n - 1) > 0;
        ans += n;
        return ans;
    }
    /**
     * 大佬的方法 ，我裂开了 爷吐了
     * 利用求和公式 n*(n + 1) / 2，不能用乘法，
     * 就用多个 2 的幂的和 来代替 n*(n + 1)
     *
     * 负数在参与位运算时使用的是补码
     * -1的原码是   10000000 00000000 00000000 00000001
     * -1的反码是   11111111 11111111 11111111 11111110
     * -1的补码是   11111111 11111111 11111111 11111111
     * 因此任何数与-1做与运算的结果任然为原数
     */
    public int sumNums_dalao(int n) {
        /**
         * 由等差数列求和公式可知，结果等于n*(n+1)/2，其中除以2可以通过右移1位进行操作
         * 但n*(n+1)在不允许使用乘法的情况下，只能把n或n+1其中一个拆解为2的n次幂数之和，配合另一个来进行位运算和累加
         * 此代码利用了-1和任何整数进行与运算还等于原数的特点
         * -(n + 1 >> 0 & 1)用于求从低到高第i+1位如果为0取，如果为1取-1
         */
        //因为题目设定 n < 10000，n 可能的最大拆分项为 2^13 = 8192

        /* 例：
        * (n>>3)&1可以通过结果判断n的二进制第3位是0或者1，
        * (0-((n>>3)&1))可以决定此次相加是否有效，
        * 如果有效(0-((n>>3)&1))=-1，
        * 然后(n+1)&(-1)=(n+1)还是其本身,再通过左移3位实现×8的效果，
        * 如果无效(0-((n>>3)&1))=0，(n+1)&0=0,此时在左移3位，结果还是0.
        *
        *
        * */
        int n1 = (n & -(n + 1 >> 0 & 1)) << 0;  // n * 2^0
        int n2 = (n & -(n + 1 >> 1 & 1)) << 1; // n * 2^1
        int n3 = (n & -(n + 1 >> 2 & 1)) << 2; // n * 2^2
        int n4 = (n & -(n + 1 >> 3 & 1)) << 3;// n & (-1) * 2^3  = n * 2^3
        int n5 = (n & -(n + 1 >> 4 & 1)) << 4; // n * 2^4
        int n6 = (n & -(n + 1 >> 5 & 1)) << 5; // n * 2^5
        int n7 = (n & -(n + 1 >> 6 & 1)) << 6; // n * 2^6
        int n8 = (n & -(n + 1 >> 7 & 1)) << 7; // n * 2^7
        int n9 = (n & -(n + 1 >> 8 & 1)) << 8; // n * 2^8
        int n10 = (n & -(n + 1 >> 9 & 1)) << 9; // n * 2^9
        int n11 = (n & -(n + 1 >> 10 & 1)) << 10; // n * 2^10
        int n12 = (n & -(n + 1 >> 11 & 1)) << 11; //...
        int n13 = (n & -(n + 1 >> 12 & 1)) << 12;//...
        int n14 = (n & -(n + 1 >> 13 & 1)) << 13;//...
        return (n1 + n2 + n3 + n4 + n5 + n6 + n7 + n8 + n9 + n10 + n11 + n12 + n13 + n14) >> 1;
    }

}
